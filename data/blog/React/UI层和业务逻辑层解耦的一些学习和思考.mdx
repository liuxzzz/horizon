---
title: UI层和业务逻辑层解耦的一些学习和思考
date: '2025-10-24'
tags: ['React', 'Nextjs', 'Frontend']
draft: false
---


在过往的一些项目实践中，当业务逻辑复杂度上升时，很容易出现UI和业务逻辑代码耦合在一起，单文件代码甚至超过3000行，造成代码混乱，不易维护。
分析以上原因出现的情况：
1. 前期的代码架构设计没有设计好，模块与模块之间的拆分足够清晰明了，但是一个单个的复杂模块也需要进行优秀的代码设计。
2. 组件的拆分不够优秀
3. 状态的管理模式出现问题，只当作一个状态的存储器，没有结合更多的业务逻辑。

所以针对以上三个问题，结合一些开源代码的学习对三个问题进行逐个学习击破。

### 1. 前期的架构设计
//TODO

### 2. 组件的拆分
-  单一职责原则 - 一个组件只做一件事


### 3. 状态的管理

组件应只负责UI渲染和事件绑定，按照react 的思想，组件应该是一个纯函数，根据输入（data），渲染组件（f），得到输出。
所以业务逻辑应当写在 Store和 Hooks中。让组件回归到一个纯净的状态。
那么问题又来了，哪些业务逻辑应当写在Store，又哪些逻辑应当写在Hooks中呢？
#### Store 应该包含的业务逻辑
1. 核心状态管理: 数据状态、持久化、跨组件共享。 是一些基于状态的派生数据
2. 数据持久化: 数据保存、加载、同步

#### Hook 应该包含的业务逻辑
1. 用户交互逻辑: 用户操作、事件处理、UI状态。 
2. 复杂计算和派生状态: 复杂计算、性能优化、副作用
3. 跨Store协调: 多个Store之间的协调

总结：
UI组件: 只负责渲染和用户交互
Store: 负责状态管理和业务逻辑
- ✅ 数据状态管理：存储应用的核心数据
- ✅ 数据持久化：保存、加载、同步数据
- ✅ 业务规则：数据验证、业务逻辑
- ✅ 跨组件共享：多个组件需要访问的状态
- ✅ 派生数据：基于状态的计算结果
- ❌ UI状态：组件内部的临时状态
- ❌ 用户交互：事件处理、用户操作

Hooks: 负责复杂逻辑封装和复用

- ✅ 用户交互逻辑：事件处理、用户操作
- ✅ 复杂计算：性能优化、缓存管理
- ✅ 副作用处理：API调用、定时器、订阅
- ✅ 跨Store协调：多个Store之间的操作
- ✅ UI状态管理：组件内部状态
- ✅ 可复用逻辑：多个组件共享的逻辑
- ❌ 核心数据存储：应该放在Store中
- ❌ 数据持久化：应该通过Store处理
